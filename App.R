# This shiny application is designed to analyse Fv/Fm mesured with a fluorcam 
# using the data from the .TXT files generated by the fluorcam software.
# The user interface allows using the script without any R knowledge.

# Copyright (c) 2025 CÃ©cile LECAMPION, Ben FIELD

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Install necessary packages if not allready done. Uncomment the lines on the first use of the application 
# and renew if necessary at each new R or R-studio version

# if (!require(shiny)) {install.packages("shiny")} #for shiny app
# if (!require(shinyFiles)) {install.packages("shinyFiles")} #for file selection
# if (!require(tidyr)) {install.packages("tidyr")} #for data manipulation
# if (!require(data.table)) {install.packages("data.table")} #for data manipulation
# if (!require(sortable)) {install.packages("sortable")} #for sortable table
# if (!require(colourpicker)){install.packages("colourpicker")} #for color selection
# if (!require(dplyr)) { install.packages("dplyr") } #for data manipulation
# if (!require(tidyverse)) { install.packages("tidyverse") } #for data manipulation
# if (!require(devtools)) { install.packages("devtools") } #for data manipulation
# if (!require(rstatix)) { install.packages("rstatix", repos = "https://cloud.r-project.org") } #for statistical test
# if (!require(ggbeeswarm)) { install.packages("ggbeeswarm") } #for function geom_quasirandom
# if (!require(RColorBrewer)) { install.packages("RColorBrewer") } #to define colors
# if (!require(rcompanion)) { install.packages("rcompanion") } #to compute confidence interval for non parametric data
# if (!require(readxl)) { install.packages("readxl") } #to read excel files
# if (!require(forcats)) { install.packages("forcats") } #for fct_reorder
# if (!require(ggplot2)) { install.packages("ggplot2") } #for the command summarySE
# if (!require(plyr)) { install.packages("plyr") } # rmisc dependency
# if (!require(Rmisc)) { install.packages("Rmisc") } # for the command summarySE
# if (!require(multcompView)) { install.packages("multcompView") } # for cld letters


library(shiny) #for shiny app
library(shinyFiles) #for file selection
library(fs)  #for file manipulation
library(tidyr) #for data manipulation
library(data.table) #for data manipulation
library(sortable) #for sortable table
library(colourpicker) #for color selection
library(ggbeeswarm) # for function geom_quasirandom
library(RColorBrewer) # to define colors
library(rstatix)  # for statistical test
library(rcompanion) # to compute confidence interval for non parametric data
library(forcats) # for fct_reorder
library(Rmisc) # for the command summarySE
library(plyr) # rmisc dependency
library(multcompView) # for cld letters
library(ggplot2) # for plotting
library(dplyr) # for data manipulation
library(ggbeeswarm) # for geom_quasirandom
library(zip) # to create zip files

########################################################################################################################################
# Function used in the script
########################################################################################################################################
# Define a function to check normality status of the data
check_normality <- function(shapiro_df) {
  # Assume normality is true initially
  flag_normal <- TRUE
  
  for (i in 1:nrow(shapiro_df)) {
    if (shapiro_df$p[i] <= 0.05) {
      # If any data group does not follow a normal law, stop and flag as non-normal
      flag_normal <- FALSE
      break
    }
  }
  
  return(flag_normal)
}


# Define a function to perform Dunn test
test_dunn <- function(df_data, var1, var2, MEASURE_COL) {
  pval <- df_data %>%
    group_by(!!sym(var1)) %>%
    dunn_test(formula = as.formula(paste(MEASURE_COL, "~", var2)), p.adjust.method = "BH") %>%
    as.data.frame()
  return(pval)
}
########################################################################################################################################

########################################################################################################################################
# Define the UI
########################################################################################################################################

ui <- fluidPage(
  titlePanel("Fluorcam data analysis tool box"),    # Title of the application
  
  sidebarLayout(                                    # Define the layout of the sidebar
    sidebarPanel(
      tags$p(
        style = "font-size: 120%; color: blue;",    # Define the style of the text
        tags$strong("1- Load data:")
      ),
      shinyDirButton("dir", "Directory selection", "Select Directory"), # Button to select the directory
      verbatimTextOutput("dirpath"),                                    # Display the selected directory
      textInput("pattern", "Select files pattern", value = ".TXT"),     # Define the pattern of the files to load
      actionButton("show_all", "Show Files : All/Short list"),          # Button to show all files or only the first 5
      textInput("areas", "Define names of areas", value = "Area 1,Area 2,Area 3,Area 4"), # Define the names of the areas
      tags$hr(),                                                        # Add a horizontal line
      tags$p(tags$strong("Collect informations about sample in file name :"),             # Add a paragraph with a strong text
             tags$br(),
             "Your file name must respect the pattern : VAR1_VAR2_VAR3.TXT",
             tags$br(),
             "Define correspondance to variable :"),
      textInput("var1", "Name of VAR1", value = "Day"),              # Define the name of VAR1
      textInput("var2", "Name of VAR2", value = "Line"),             # Define the name of VAR2
      textInput("var3", "Name of VAR3", value = "PlantID"),          # Define the name of VAR3
      actionButton("load", "Load data"),
      tags$p(
        style = "font-size: 120%; margin-top: 20px; color: blue;",
        tags$strong("2- Graph and statistical analysis parameters :") # Add a paragraph with a strong text
      ),
      tags$p(tags$strong("Define order of the lines and of the facets : \n"), 
             "Drag the lines to change the order.",
             uiOutput("var2_order_ui"), 
             uiOutput("var1_order_ui")),
      tags$p(tags$strong("Select colors for your graph :")), 
      colourInput("line_color", "Line color", value = "darkgrey"),         # Define the color of the lines
      colourInput("fill_color", "Fill color", value = "ivory1"),           # Define the color of the fill
      colourInput("point_color", "Point color", value = "darkgreen"),      # Define the color of the points
      uiOutput("columnSelect"),                                            # Display the column selection
      actionButton("start_analysis", "Start Analysis"),                    # Button to start the analysis
      downloadButton("download_parametric", "Download All Analysis Results for parametric data"), # Button to download the results for parametric data
      downloadButton("download_non_parametric", "Download All Analysis Results for non-parametric data") # Button to download the results for non-parametric data
    ),
 
    # Define the main panel   
    mainPanel( 
      tableOutput("selected_files"),          # Display the selected files
      tags$hr(),
      tableOutput("processed_data"),          # Display the processed data
      uiOutput("toggle_button"),              # Display the toggle button to controle the visible part of the generated table
      tags$hr(),
      textOutput("selectedValue"),            # Display the selected value, the one that will be analysed
      verbatimTextOutput("normality_result"), # Display the normality result
      plotOutput("plot_result")               # Display the plot result
    )
  )
)


########################################################################################################################################
# Define the server
########################################################################################################################################

server <- function(input, output, session) { 
  volumes <- c(Home = fs::path_home(), "R" = R.home(), getVolumes()()) # Define the volumes to search for the files
  
  shinyDirChoose(input, "dir", roots = volumes, session = session)     # Choose the directory were the files are
  
  dirpath <- reactive({                                                # Define the reactive value for the directory path
    parseDirPath(volumes, input$dir)
  })
  
  output$dirpath <- renderText({                                       # Display the directory path
    dirpath()
  })
  
  show_all_files <- reactiveVal(FALSE)                                 # Define the reactive value to show all files or only the first 5
  
  observeEvent(input$show_all, {                                       # Observe the event to show all files or only the first 5
    show_all_files(!show_all_files())
  })
  
  output$selected_files <- renderTable({                               # Display the selected files
    req(dirpath(), input$pattern)
    files <- list.files(path = dirpath(), pattern = input$pattern, full.names = TRUE)
    
    if (!show_all_files()) {                                          # Show all files or only the first 5
      files <- head(files, 5)
    }
    
    data.frame(Fichier = basename(files))
  })
  
  process_data_files <- function(pattern, areas, var1, var2, var3, dirpath) {   # Define the function to process the data files
    areas <- unlist(strsplit(areas, ","))                                       # Split the areas
    
    remove_first_two_lines <- function(file_name) {                             # Define the function to remove the first two lines
      data <- read.table(file_name, skip = 2, sep = "\t", header = TRUE)
      return(data)
    }
    
    compute_Fv_Fm <- function(df) {                                             # Define the function to compute Fv/Fm
      df$Fv_Fm <- df$Fv / df$Fm
      return(df)
    }
    
    add_name_column <- function(df, name) {                                     # Define the function to add the name column
      df$Name <- name
      return(df)
    }
    
    divide_name <- function(df) {                                               # Define the function to divide the name of the file into 3 variables
      df <- tidyr::separate(data = df, col = "Name", into = c(var1, var2, var3), sep = "_", remove = TRUE)
      return(df)
    }
    
    files <- list.files(path = dirpath, pattern = pattern, full.names = TRUE)   # List the files
    print(paste("Files found:", files))                                         # Print the files found
    
    Liste <- lapply(files, remove_first_two_lines)                              # Remove the first two lines
    names(Liste) <- tools::file_path_sans_ext(basename(files))                  # Define the names of the files
    
    Liste <- lapply(Liste, data.table::transpose, make.names = "X")             # Transpose the data
    
    Liste <- lapply(Liste, compute_Fv_Fm)                                       # Compute Fv/Fm
    
    Liste <- lapply(names(Liste), function(name) {                              # Add the name column
      add_name_column(Liste[[name]], name)
    })
    
    Liste <- lapply(Liste, divide_name)                                         # Divide the name of the file into 3 variables  
    
    df <- do.call(rbind, Liste)                                                 # Bind the data
    df <- cbind(Area = rep(areas, length.out = nrow(df)), df)                   # Add the area column
    
    return(df)                                                                  # Return the data
  }
  
  result_df <- reactiveValues(data = NULL)                                      # Define the reactive values for the processed data to make them available for later use
  
  observeEvent(input$load, {                                                    # Observe the event to load the data
    pattern <- input$pattern                                                    # Define the pattern
    areas <- input$areas                                                        # Define the areas
    var1 <- input$var1                                                          # Define the name of VAR1
    var2 <- input$var2                                                          # Define the name of VAR2
    var3 <- input$var3                                                          # Define the name of VAR3
    dir_path <- dirpath()                                                       # Define the directory path
    
    result_df$data <- process_data_files(                                       # Process the data files
      pattern = pattern, 
      areas = areas, 
      var1 = var1, 
      var2 = var2, 
      var3 = var3, 
      dirpath = dir_path
    )
    
    # Add the button to collapse the table
    output$toggle_button <- renderUI({                                          # Display the button to toggle the table
      req(result_df$data)                                                       # Require the data
      actionButton("toggle_table", "Show/Hide Full Table")                      # Add the action button
    })
    
    # Define the reactive values to store the state of the button
    show_full_table <- reactiveValues(full = FALSE)                            
    
    # Observe the event to toggle the table
    observeEvent(input$toggle_table, {                                          
      show_full_table$full <- !show_full_table$full
    })
    
    # Display the processed data
    output$processed_data <- renderTable({                                     
      req(result_df$data)
      
      if (show_full_table$full) {
        result_df$data
      } else {
        head(result_df$data, 5)                                                 # Display only the first 5 rows
      }
    })
  })
  
  # Display the column selection
  output$columnSelect <- renderUI({                                             
    req(result_df$data)
    selectInput("column", "Select the column containing the parameter to analyse", 
                choices = colnames(result_df$data))
  })
  
  VALUE <- reactive({                                                           # Define the reactive value for the selected value
    req(input$column)
    input$column
  })
  
  # Display the order of the lines
  output$var2_order_ui <- renderUI({                                             
    req(result_df$data)
    rank_list(
      text = "Order of lines (VAR2)",
      labels = unique(result_df$data[[input$var2]]),
      input_id = "var2_order"
    )
  })
  
  # Display the order of the facets
  output$var1_order_ui <- renderUI({
    req(result_df$data)
    rank_list(
      text = "Order of facets (VAR1)",
      labels = unique(result_df$data[[input$var1]]),
      input_id = "var1_order"
    )
  })
  
  # color slection
  line_color <- reactive({ 
    req(input$line_color)
    input$line_color
  })
  
  fill_color <- reactive({
    req(input$fill_color)
    input$fill_color
  })
  
  point_color <- reactive({
    req(input$point_color)
    input$point_color
  })
  

  # Data processing and statistical analysis
  analysis_result <- eventReactive(input$start_analysis, { 
    req(result_df$data, VALUE())
    
    var1 <- input$var1
    var2 <- input$var2
    MEASURE_COL <- VALUE() 
    
    # Convert variables to factors
    result_df$data[[var1]] <- as.factor(result_df$data[[var1]])
    result_df$data[[var2]] <- as.factor(result_df$data[[var2]])
    
    # Compute Shapiro Test
    shapiro_result <- reactive({ 
      req(var1, var2, MEASURE_COL)
      
      shapiro_df <- result_df$data %>%
        group_by(!!sym(var2), !!sym(var1)) %>%
        shapiro_test(!!sym(MEASURE_COL))
      
      return(shapiro_df)
    })
    
    # Normality check
    normality_check <- reactive({ 
      shapiro_df <- shapiro_result()
      flag_normal <- check_normality(shapiro_df)
      return(flag_normal)
    })
    
    # Displaying the result of the normality test
    output$normality_result <- renderText({
        if (normality_check()) {
          "Datas follow a normal law."
        } else {
          "Datas don't follow a normal law."
        }
  })
 
  
  # Data analysis according to normality status
  if (normality_check()) {                                  # If the data follow a normal law
    # Summary
    library(plyr)
    library(Rmisc)
    my_summary <- summarySE(result_df$data, measurevar = MEASURE_COL, groupvars = c(var2, var1)) 
    
    # Statistical tests
    # ANOVA Test
    anova_result <- result_df$data %>%
      group_by(!!sym(var1)) %>%
      rstatix::anova_test(formula = reformulate(var2, MEASURE_COL))
    
    # Tukey HSD Test
    tukey_results <- result_df$data %>%
      group_by(!!sym(var1)) %>% 
      rstatix::tukey_hsd(as.formula(paste(MEASURE_COL, "~", var2)))
    
    # CLD letters for parametric test
    cld_table_parametric <- tukey_results %>%
      group_by(!!sym(var1)) %>%
      summarise(cld = list(multcompView::multcompLetters(setNames(p.adj, paste(group1, group2, sep = "-")), 
                                                         Letters = letters)$Letters),
                .groups = 'drop') %>%
      unnest_longer(cld) %>%
      mutate(!!var2 := names(cld))
    
    # Plotting
    df2 <- merge(my_summary, cld_table_parametric, by.x = c(var2, var1), by.y = c(var2, var1))
        # Variable as factor
    df2[[var1]] <- factor(df2[[var1]], levels = input$var1_order) 
    df2[[var2]] <- factor(df2[[var2]], levels = input$var2_order)
    result_df$data[[var1]] <- factor(result_df$data[[var1]], levels = input$var1_order)
    result_df$data[[var2]] <- factor(result_df$data[[var2]], levels = input$var2_order)
    
    p <- df2 %>%
      mutate(!!sym(var1) := as.factor(!!sym(var1)),
             !!sym(var2) := as.factor(!!sym(var2))) %>%
      ggplot(aes(x = !!sym(var2), y = !!sym(MEASURE_COL), fill = !!sym(var2))) +
      geom_col(color = line_color(), width = 0.6, position = position_dodge2(padding = 0.05)) +
      scale_fill_manual(values = rep(fill_color(), length(unique(df2[[var2]])))) +
      scale_y_continuous(
        expand = expansion(mult = c(0, 0.1)), 
        breaks = seq(0, 1, by = 0.2))  +
      geom_quasirandom(data = result_df$data, 
                       aes(x = !!sym(var2), y = !!sym(MEASURE_COL)), 
                       color = point_color(), 
                       width = 0.3, alpha = 0.6) +
      geom_segment(aes(x = !!sym(var2), xend = !!sym(var2), y = pmax(0, !!sym(MEASURE_COL) - ci), yend = !!sym(MEASURE_COL) + ci), 
                   color = "black") +
      geom_text(aes(x = !!sym(var2), y = !!sym(MEASURE_COL) + (0.15 * max(df2[[MEASURE_COL]], na.rm = TRUE)), label = cld), 
                size = 3, inherit.aes = TRUE) +
      theme_classic() +
      theme(
        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        axis.line.x = element_line(linewidth = 0.5),
        axis.line.y = element_line(linewidth = 0.5),
        panel.background = element_rect(fill = 'transparent', color = NA),
        plot.background = element_rect(fill = 'transparent', color = NA),
        axis.text.y = element_text(vjust = 1),
        legend.position = "none",
        strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(face = "plain", size = 10, color = "black", hjust = 0.5)) +
      facet_wrap(as.formula(paste("~", var1)), nrow = 1) +
      labs(x = "Treatment", y = "Median Value")
    
    output$plot_result <- renderPlot({
      print(p)
    })
    
    ggsave("plot_para.svg", width = 8, height = 6)
    
    # Download all the tables as a ZIP file for parametric data
    output$download_parametric <- downloadHandler(
      filename = function() {
        paste("parametric_analysis_results_", Sys.Date(), ".zip", sep = "")
      },
      content = function(file) {
        temp_dir <- tempdir()
        shapiro_file <- file.path(temp_dir, "shapiro_test_results.csv")
        write.csv(shapiro_result(), shapiro_file, row.names = FALSE)
        my_summary_file <- file.path(temp_dir, "summary_results.csv")
        write.csv(my_summary, my_summary_file, row.names = FALSE)
        anova_file <- file.path(temp_dir, "anova_results.csv")
        write.csv(anova_result, anova_file, row.names = FALSE)
        tukey_file <- file.path(temp_dir, "tukey_results.csv")
        write.csv(tukey_results, tukey_file, row.names = FALSE)
        cld_file <- file.path(temp_dir, "cld_table_parametric.csv")
        write.csv(cld_table_parametric, cld_file, row.names = FALSE)
        
        zip::zipr(file, 
                  files = c(shapiro_file, my_summary_file, anova_file, tukey_file, cld_file), 
                  compression_level = 9)
      }
    )
    
  } else {                                                 # If the data don't follow a normal law
    # Summary
    conf_int <- groupwiseMedian(
      data = result_df$data,
      var = MEASURE_COL,
      group = c(var2, var1),
      conf = 0.95,
      R = 5000,
      percentile = TRUE,
      bca = FALSE,
      digits = 3)
    
    # Statistical tests
    # Kruskal-Wallis Test
    kruskal_pval <- result_df$data %>%
      group_by(!!sym(var1)) %>%
      kruskal_test(as.formula(paste(MEASURE_COL, "~", var2))) %>%
      dplyr::select(all_of(var1), p)
    
    significant <- any(kruskal_pval$p < 0.05)
    
    # Dunn Test and CLD letters
    if (significant) {
      pval_dunn <- test_dunn(result_df$data, var1, var2, MEASURE_COL)
      
      # CLD letters for non-parametric test
      cld_table_nonparametric <- pval_dunn %>%
        group_by(!!sym(var1)) %>%
        summarise(
          cld = list(multcompView::multcompLetters(setNames(p.adj, paste(group1, group2, sep = "-")), 
                                                   Letters = letters)$Letters),
          .groups = 'drop') %>%
        unnest_longer(cld) %>%
        mutate(!!var2 := names(cld))
      
      # Plotting
      df2 <- merge(conf_int, cld_table_nonparametric, by.x = c(var2, var1), by.y = c(var2, var1))
             # Variable as factor
      df2[[var1]] <- factor(df2[[var1]], levels = input$var1_order)
      df2[[var2]] <- factor(df2[[var2]], levels = input$var2_order)
      result_df$data[[var1]] <- factor(result_df$data[[var1]], levels = input$var1_order)
      result_df$data[[var2]] <- factor(result_df$data[[var2]], levels = input$var2_order)
      
      p <- df2 %>%
        ggplot(aes(x = !!sym(var2), y = Median, fill = !!sym(var2))) +
        geom_col(color = line_color(), width = 0.6, position = position_dodge2(padding = 0.05)) +
        scale_fill_manual(values = rep(fill_color(), length(unique(df2[[var2]])))) +
        scale_y_continuous(expand = expansion(mult = c(0, 0.1)), 
                           breaks = seq(0, 1, by = 0.2) ) +
        geom_quasirandom(data = result_df$data, 
                         aes(x = !!sym(var2), y = !!sym(MEASURE_COL)), 
                         color = point_color(), width = 0.3, alpha = 0.6) +
        geom_segment(aes(x = !!sym(var2), xend = !!sym(var2), y = pmax(0, Percentile.lower), yend = Percentile.upper), 
                     color = "black") +
        geom_text(aes(x = !!sym(var2), y = Percentile.upper + (0.15 * Median), label = cld), 
                  size = 3, inherit.aes = TRUE) +
        theme_classic() +
        theme(
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
          axis.line.x = element_line(linewidth = 0.5),
          axis.line.y = element_line(linewidth = 0.5),
          panel.background = element_rect(fill = 'transparent', color = NA),
          plot.background = element_rect(fill = 'transparent', color = NA),
          axis.text.y = element_text(vjust = 1),
          legend.position = "none",
          strip.background = element_blank(),
          strip.placement = "outside",
          strip.text = element_text(face = "plain", size = 10, color = "black", hjust = 0.5)) +
        facet_wrap(as.formula(paste("~", var1)), nrow = 1, scales = "free_y") +
        labs(x = "Treatment", y = "Median Value")
      
      output$plot_result <- renderPlot({
        print(p)
      })
      
      ggsave("plot_nonpara.svg", width = 8, height = 6)
      
    } else {                                                             # If the data are not significantly different
      print("Data are not significantly different, the Dunn test was not performed.")
      
    }
  }
  
    # Download all the tables as a ZIP file for non-parametric data
    output$download_non_parametric <- downloadHandler(
      filename = function() {
        paste("parametric_analysis_results_", Sys.Date(), ".zip", sep = "")
      },
      content = function(file) {
        temp_dir <- tempdir()
        shapiro_file <- file.path(temp_dir, "shapiro_test_results.csv")
        write.csv(shapiro_result(), shapiro_file, row.names = FALSE)
        conf_int_file <- file.path(temp_dir, "confidence_interval_results.csv")
        write.csv(conf_int, conf_int_file, row.names = FALSE)
        kruskal_file <- file.path(temp_dir, "kruskal_results.csv")
        write.csv(kruskal_pval, kruskal_file, row.names = FALSE)
        dunn_file <- file.path(temp_dir, "dunn_results.csv")
        write.csv(pval_dunn, dunn_file, row.names = FALSE)
        cld_file <- file.path(temp_dir, "cld_table_nonparametric.csv")
        write.csv(cld_table_nonparametric, cld_file, row.names = FALSE)
        
        zip::zipr(file, 
                  files = c(shapiro_file, conf_int_file, kruskal_file, dunn_file, cld_file), 
                  compression_level = 9)
      }
    )
  })
  
  observeEvent(input$start_analysis, {
    analysis_result()
  })
}

########################################################################################################################################
# Run the application
########################################################################################################################################
shinyApp(ui = ui, server = server)