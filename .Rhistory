ggplot(data=JoinAbstractPerCountry, aes(x=pourcent, y=Country)) +
geom_bar(stat="identity", position=position_dodge(), fill = '#93c14a')+
scale_x_continuous(
expand = c(0, 0), # The horizontal axis does not extend to either side
position = "top"  # Labels are located on the top
) +
scale_y_discrete(expand = expansion(add = c(0, 0.5))) +
theme(
# Set background color to white
panel.background = element_rect(fill = "white"),
# Set the color and the width of the grid lines for the horizontal axis
panel.grid.major.x = element_line(color = "#A8BAC4", size = 0.3),
# Remove tick marks by setting their length to 0
axis.ticks.length = unit(0, "mm"),
# Remove the title for both axes
axis.title = element_blank(),
# Only left line of the vertical axis is painted in black
axis.line.y.left = element_line(color = "black"),
# Remove labels from the vertical axis
#axis.text.y = element_blank(),
# But customize labels for the horizontal axis
axis.text.x = element_text(family = "Work Sans", size = 16))
colnames(abstract)[grepl("Would.you.like", colnames(abstract))] <- "FESPB_poster_award"
AbstractPeraward <- abstract %>%
group_by(FESPB_poster_award) %>%
summarize(count=n())
View(AbstractPeraward)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
View(ParticipantPerpaymentstatus)
View(ParticipantPerpaymentstatus)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
ParticipantPerpaymentstatus$`Participant State` <- c("Online", "Proof Required", "Paid", "Unpaid", "Wait list",)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
ParticipantPerpaymentstatus$`Participant State` <- c("Online", "Proof Required", "Paid", "Unpaid", "Wait list")
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
ParticipantPerpaymentstatus$`Participant State` <- c("Wait list", "Proof Required","Online", "Unpaid", "Paid")
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
ParticipantPerpaymentstatus$`Participant State` <- c("Wait list", "Proof Required","Online", "Unpaid", "Paid")
ParticipantPerpaymentstatus$`Participant State`
length(ParticipantPerpaymentstatus$`Participant State`)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
length(ParticipantPerpaymentstatus$`Participant State`)
View(ParticipantPerpaymentstatus)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
View(ParticipantPerpaymentstatus)
View(participants)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
#ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
#ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
#ParticipantPerpaymentstatus$`Participant State` <- c("Wait list", "Proof Required", "Online", "Unpaid", "Paid")
View(ParticipantPerpaymentstatus)
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
#ParticipantPerpaymentstatus$`Participant State` <- c("Wait list", "Proof Required", "Online", "Unpaid", "Paid")
View(ParticipantPerpaymentstatus)
knitr::opts_chunk$set(echo = TRUE)
setwd("~/Plant_Biology_Europe_2023/participants")
speaker <- read_xlsx("keynote_country.xlsx")
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(shadowtext)
library(gridExtra)
setwd("~/Plant_Biology_Europe_2023/participants")
speaker <- read_xlsx("keynote_country.xlsx")
session_organizers <- read_xlsx("session_country.xlsx")
participants <- read_xls("2023-04-18_10-06-07_en_PBE23_ParticipantList.xls")
participants <- participants[-c(1:5),]
names(participants) <- participants[1,]
participants <- participants[-c(1),]
ParticipantPerpaymentstatus <- participants %>%
group_by(`Participant State`) %>%
summarize(count=n())
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus[order(ParticipantPerpaymentstatus$count),]
ParticipantPerpaymentstatus <- ParticipantPerpaymentstatus %>%  drop_na(`Participant State`)
ParticipantPerpaymentstatus$`Participant State` <- c("Wait list", "Proof Required", "Online", "Unpaid", "Paid")
View(ParticipantPerpaymentstatus)
View(participants)
View(participants)
levels(participants$`Participant State`)
levels(as.factor(participants$`Participant State`))
library(edgeR)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("edgeR")
library(biomaRt)
? biomaRt
listEnsembl()
ensembl = useEnsembl(biomart="ensembl")
head(listDatasets(ensembl))
ensembl = useEnsembl(biomart="ensembl", dataset="ppatens_gene_ensembl")
listDatasets()
ensembl = useEnsembl(biomart="ensembl")
listDatasets(ensembl)
knitr::opts_chunk$set(echo = TRUE)
# le chemin vers répertoire de travail/projet
Dir <- "/Volumes/X9_Pro/crible_benoit_032024/annotation"
# définir Dir comme working directory
setwd(Dir)
# nom du vcf
vcf_file <- "/Volumes/X9_Pro/crible_benoit_032024/annotation/pool_GATK_PF.SNP.filtered.ann.vcf"
# pour chercher l'aide d'une fonction utiliser la fonction help() ou ?
# help(read.vcfR)
# ?read.vcfR()
vcf <- vcfR::read.vcfR(file = vcf_file)
# pour vérifier le type ou la class d'un objet on utilise summary(), class(), is()
#summary(vcf)
# la fonction "vcfR2tidy" prend en entrée un objet vcfR
# pour connaitre le type d'un objet on fait la commande : is(vcf.snv)
# on peut specifier les champs que on veux garder (ex ci-dessous)
# vcf.tidy.list <- vcfR2tidy(vcf.snv, format_fields = c("GT", "AD", "DP"), info_fields = c("AC", "AN", "MQ"))
vcf.tidy.list <- vcfR2tidy(vcf)
library(vcfR)        # extraire les informations stockées dans un VCF
library(tidyverse)   # collection de packages R pour la manipulation et la visualisation des données,
library(reshape2)    # transform les data frame
library(ggplot2)     # visualisation
library(UpSetR)      # upset plot -> graphique d'intersection
library(venn)        # diagramme de venn
# la fonction "vcfR2tidy" prend en entrée un objet vcfR
# pour connaitre le type d'un objet on fait la commande : is(vcf.snv)
# on peut specifier les champs que on veux garder (ex ci-dessous)
# vcf.tidy.list <- vcfR2tidy(vcf.snv, format_fields = c("GT", "AD", "DP"), info_fields = c("AC", "AN", "MQ"))
vcf.tidy.list <- vcfR2tidy(vcf)
# "ChromKey", "POS" sont les colonnes communes
vcf.tidy <- dplyr::full_join(vcf.tidy.list$fix , vcf.tidy.list$gt, by = c("ChromKey", "POS"))
#head(vcf.tidy)
## exmple :
# CHROM <- "Chr1"
# POS <- 10000
# REF <- "A"
# ALT <- "T"
# ID  <- paste(CHROM, POS, REF, ALT, sep="_") # résultats : Chr1_10000_A_T
# Pour chaque variant si ID n'est pas null, créer le ID (comme dans l'ex.), sinon garder le ID.
vcf.tidy <- dplyr::mutate(vcf.tidy, ID = dplyr::if_else(is.na(ID), paste(CHROM, POS, REF, ALT, sep="_"), ID))
head(vcf.tidy)
# les variants multi-alléliques
#stringr::str_detect(string = vcf.tidy$ALT, pattern = ",")
#dplyr::filter(vcf.tidy, stringr::str_detect(string = vcf.tidy$ALT, pattern = ",")) %>% select(ID, ALT, gt_AD) %>% head
vcf.tidy.multiAlt <- dplyr::filter(vcf.tidy, str_detect(string = ALT, pattern = ","))
vcf.tidy.multiAlt %>% dplyr::select(ID, ALT, gt_AD) %>% head
# garder les variations  avec un allele alternatif
filter(vcf.tidy, !str_detect(string = ALT, pattern = ",")) %>% dplyr::select(ID, ALT, gt_AD) %>% head
vcf.tidy <- dplyr::filter(vcf.tidy, !str_detect(string = ALT, pattern = ","))
# separarer la colonne gt_AD en deux colonne ref AD et alt AD
vcf.tidy <- tidyr::separate(data = vcf.tidy, col = gt_AD, c("gt_ref.AD", "gt_alt.AD"), sep = ",", remove=FALSE)
vcf.tidy <- vcf.tidy %>% mutate(gt_ref.AD = as.numeric(gt_ref.AD), gt_alt.AD = as.numeric(gt_alt.AD))
dplyr::select(vcf.tidy, ID, Indiv, gt_AD, gt_ref.AD, gt_alt.AD) %>% head()
#vcf.tidy <- dplyr::mutate(vcf.tidy, gt_AR = gt_alt.AD/gt_DP)
#vcf.tidy <- dplyr::mutate(vcf.tidy, gt_AR = if_else(gt_DP == 0, 0, gt_alt.AD/gt_DP))
vcf.tidy <- dplyr::mutate(vcf.tidy, gt_AR = if_else(gt_DP == 0, 0, gt_alt.AD/gt_DP))
dplyr::select(vcf.tidy, ID, Indiv, gt_AD, gt_ref.AD, gt_alt.AD, gt_AR) %>% head()
#> BONUS
A <- vcf.tidy %>% separate(col=gt_GT_alleles, into = c("ref", "alt"), sep="[|/.]", remove = FALSE) %>% dplyr::select(gt_GT_alleles, ref, alt)
p <- ggplot(data=vcf.tidy) +
geom_density(aes(QUAL, color=Indiv)) +
xlab("score de qualité") + ylab("densité") + xlim(c(0,100))
p
p <- ggplot(data=vcf.tidy) +
geom_density(aes(gt_DP, color=Indiv)) +
xlab("Variant position coverage") + ylab("densité") + xlim(c(0,100))
p
p <- ggplot(data=vcf.tidy) +
geom_density(aes(gt_alt.AD, color=Indiv)) +
xlab("Alternative allele depth") + ylab("densité") + xlim(c(0,50))
p
p <- ggplot(data=vcf.tidy) +
geom_density(aes(gt_AR, color=Indiv)) +
xlab("Alternative allele ratio") + ylab("densité")
p
# filtrer les variations avec un score qualité inférieur à 30
vcf.tidy.flt.q <- dplyr::filter(vcf.tidy, QUAL >= 30)
# les positions couvertes à moins de 4 reads seront considérés comme non couverte
# l'allèle alternatif doit être supporté par au moins 2 reads.
vcf.tidy.flt <- dplyr::mutate(vcf.tidy.flt.q, gt_DP = if_else(gt_DP < 4, 0, as.numeric(gt_DP)),
gt_alt.AD = if_else(gt_alt.AD < 2, 0, as.numeric(gt_alt.AD)))
# on peut aussi appliquer des filtre sur l'allèle ratio
# compter le nombre de positions non couvertes par échantillon.
NA_count_samples <- dplyr::select(vcf.tidy.flt.q, ID, Indiv, gt_DP) %>%
dplyr::group_by(Indiv) %>% count(is.na(gt_DP)) %>%
dplyr::filter(`is.na(gt_DP)` == TRUE)
head(NA_count_samples)
p <- ggplot(data=NA_count_samples) +
geom_bar(aes(y=n, x=Indiv), stat = "identity") +
theme(axis.text.x = element_text(angle = 90, size = rel(0.8), hjust = 0))
print(p)
var.mat.DP <- dplyr::select(vcf.tidy.flt.q, ID, Indiv, gt_DP) %>%
reshape2::dcast(ID~Indiv, value.var = "gt_DP") %>%
dplyr::mutate(NA_count = rowSums(is.na(dplyr::select(., -ID))))
p <- ggplot(data=var.mat.DP, aes(as.factor(NA_count))) + geom_bar() +
geom_text(stat='count', aes(label=..count..), vjust=-0.7) +
xlab ("Fréquence de couverture")
print(p)
# retirer les lignes variant-echantillon avec un allèle ref.
vcf.tidy.flt.q.var <- dplyr::filter(vcf.tidy.flt.q, gt_AR > 0)
# Découper la ligne et dire ce que chacune fait?
ID.uniq <- vcf.tidy.flt.q.var %>% dplyr::select(ID, Indiv) %>% dplyr::group_by(ID) %>% count()
data <- dplyr::full_join(ID.uniq, vcf.tidy.flt.q.var, by="ID") %>% dplyr::filter(Indiv == "YAK1_OE")
p <- ggplot(data=data, aes(x=as.factor(n))) + geom_bar() + geom_text(stat='count', aes(label=..count..), vjust=-0.7) + xlab("nb d'échantillons") + ggtitle("nb de variants communs à n échantillons")
print(p)
data    <- dplyr::full_join(ID.uniq, vcf.tidy.flt.q.var, by="ID") %>%
dplyr::select(Indiv, n) %>% dplyr::group_by(n, Indiv) %>% count() %>% filter(n != 15)
ggplot(data=data, aes(x=as.factor(n), y=nn)) + geom_boxplot(outlier.shape = NA) +
geom_point(size = 0.8, aes(color=Indiv), position=position_jitter(width = 0.2))
vcf.tidy.flt.q.var <- dplyr::filter(vcf.tidy.flt.q, gt_AR > 0)
ID.ref          <- dplyr::filter(vcf.tidy.flt.q.var, Indiv == "YAK1_OE")
vcf.tbl.non.ref <- dplyr::filter(vcf.tidy.flt.q.var, ! ID %in% ID.ref$ID)
#dim(vcf.tbl.non.ref)
#select(vcf.tbl, ID, Indiv)
#select(vcf.tbl, ID, Indiv) %>% group_by(ID)
#select(vcf.tbl, ID, Indiv) %>% group_by(ID) %>% count()
#select(vcf.tbl, ID, Indiv) %>% group_by(ID) %>% count() %>% filter(n == 1)
# test sans dplyr::select -> error pour illuster pourquoi il est important de rajouter le nom du package avnat la fonction
#ID.uniq <- select(vcf.tbl.non.ref, ID, Indiv) %>% group_by(ID) %>% count() %>% filter(n < 2)
ID.uniq <- dplyr::select(vcf.tbl.non.ref, ID, Indiv) %>% group_by(ID) %>% count() %>% filter(n < 2)
vcf.tbl.uniq1 <- dplyr::filter(vcf.tbl.non.ref, ID %in% ID.uniq$ID)
vcf.tbl.uniq <- dplyr::filter(vcf.tbl.uniq1, paste(REF, ALT, sep = "_") %in% c("C_T", "G_A"))
#dim(vcf.tbl.uniq1)
#dim(vcf.tbl.uniq)
mutations.list <- list()
# une boucle sur l'ensemble des échantillons
for(ind in unique(vcf.tidy$Indiv)){
vcf.tbl.ind         <- dplyr::filter(vcf.tidy,         Indiv==ind)
vcf.tbl.non.ref.ind <- dplyr::filter(vcf.tbl.non.ref, Indiv==ind)
vcf.tbl.uniq.ind    <- dplyr::filter(vcf.tbl.uniq,    Indiv==ind)
hom.chr <- dplyr::filter(vcf.tbl.uniq.ind, gt_AR > 0.9) %>% dplyr::select(CHROM) %>% unique()
var.to.smooth <- dplyr::filter(vcf.tbl.uniq.ind, CHROM %in% hom.chr$CHROM)
p <- ggplot() + ylim(0,1) +
geom_point( data=vcf.tbl.ind,          aes(x=POS, y=gt_AR), size=0.2, color="grey80") +
geom_point( data=vcf.tbl.non.ref.ind,  aes(x=POS, y=gt_AR), size=0.3, color="green") +
geom_point( data=vcf.tbl.uniq.ind,     aes(x=POS, y=gt_AR), size=0.5, color="red") +
geom_smooth(data=var.to.smooth, aes(x=POS, y=gt_AR), size=0.5) +
facet_grid( ~ CHROM, scale="free",  space = "free") +
theme(axis.text.x = element_text(angle = 90, size = rel(0.8), hjust = 0),
axis.text.y = element_text(size = rel(0.8), hjust = 0)) +
scale_x_continuous(breaks = seq(0, max(vcf.tbl.ind$POS), 1e+07))+
ggtitle(ind)
print(p)
# stocker le res dans une list
mutations.list[[ind]] <- var.to.smooth %>% dplyr::filter(gt_AR > 0.9)
}
# concatener les tibbles
mutations <- purrr::reduce(mutations.list, rbind)
mutations
# nom du gène field 4 et effet field 2 .
mutations.ann <-  tidyr::separate(mutations, col = ANN, into = paste("ann", 1:5, sep = ""), sep = "[|]", remove = FALSE)
mutations.ann %>% dplyr::select(ann2, ann4, ANN)
# comptage par effet
#count(mutations.ann, ann2)
#mutations.eff <- mutations.ann %>% dplyr::filter(ann2 %in% c("missense_variant", "stop_gained", "splice_acceptor_variant", "splice_donnor_varian", "splice_region_variant"))
#mutations.eff <- mutations.ann %>% dplyr::filter(str_detect(ann2, c("missense_variant", "intron_variant", "splice_region_variant", "splice_region_variant&intron_variant")))
#mutations.eff <- mutations.ann %>% dplyr::filter(str_detect(ann2, "missense_variant|intron_variant|splice_region_variant"))
#on garde toutes les mutations
mutations.eff <- mutations.ann
mutations.eff
mutations.eff %>% dplyr::select(ann2, ann4, ann5, Indiv)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("org.At.tair.db")
library(org.At.tair.db)
# list of databases
AnnotationDbi::columns(org.At.tair.db)
# selectionner les bases de sonnées
cols <- c("SYMBOL", "GO")
# gène à annoter
ensids <- mutations.eff$ann5
AnnotationDbi::select(org.At.tair.db, keys=ensids, columns=cols, keytype="TAIR")
# gènes à annoter
ensids <- mutations.eff$ann4
AnnotationDbi::select(org.At.tair.db, keys=ensids, columns=cols, keytype="TAIR")
install.packages("shiny")
library(shiny)
runExample("01_hello")
shiny::runApp('scripts_R/shiny_test')
shiny::runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
View(data)
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
shiny::runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
runApp('tmp/test_fleur')
source("~/tmp/test_fleur_sans_app.R")
source("~/tmp/test_fleur_sans_app.R")
source("~/tmp/test_fleur_sans_app.R")
shiny::runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
data <- read.table("tableau/planning.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
data <- read.table("/Users/cecile/scripts_R/planning_shiny/tableau/planning.txt", header = TRUE, sep = "\t", stringsAsFactors = FALSE)
View(data)
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
shiny::runApp('scripts_R/planning_shiny')
Sys.time()- days(2)
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
format(seq(Sys.time(), Sys.time()+ days(30), by = "1 day"), "%a %d %b"))
format(seq(Sys.time(), Sys.time()+ days(30), by = "1 day"), "%a %d %b")
c(Sys.time(), Sys.time()+ days(30))
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
data <- read.table("/Users/cecile/scripts_R/planning_shiny/tableau/planning.txt", header = TRUE, sep = "\t")
View(data)
shiny::runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
data <- read.table("/Users/cecile/scripts_R/planning_shiny/tableau/planning.txt", header = TRUE, sep = "\t")
View(data)
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
runApp('scripts_R/planning_shiny')
shiny::runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
shiny::runApp('Documents/github-repositories/shiny_fluorcam')
required_packages <- c("shiny", "shinyFiles", "fs", "tidyr", "data.table", "sortable", "colourpicker",
"ggbeeswarm", "RColorBrewer", "rstatix", "rcompanion", "forcats", "Rmisc",
"plyr", "multcompView", "ggplot2", "dplyr", "zip")
for(pkg in required_packages){
if(!require(pkg, character.only = TRUE)){
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
}
}
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
install.packages("shinyWidgets")
install.packages("shinyWidgets")
install.packages("toastui")
install.packages("toastui")
shiny::runApp('Documents/github-repositories/shiny_fluorcam')
required_packages <- c("shiny", "shinyFiles", "fs", "tidyr", "data.table", "sortable", "colourpicker",
"ggbeeswarm", "RColorBrewer", "rstatix", "rcompanion", "forcats", "Rmisc",
"plyr", "multcompView", "ggplot2", "dplyr", "zip")
for(pkg in required_packages){
if(!require(pkg, character.only = TRUE)){
install.packages(pkg, dependencies = TRUE)
library(pkg, character.only = TRUE)
}
}
runApp('Documents/github-repositories/shiny_fluorcam')
shiny::runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
shiny::runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
runApp('Documents/github-repositories/shiny_fluorcam')
